import _regeneratorRuntime from 'babel-runtime/regenerator';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import React, { Children, Component } from 'react';
import { stepperContext } from './entities';
/**
 * The component where a stepper is configured and holds all state
 * and logic for navigating a stepper.
 *
 * It does not render any UI by itself and must be accompanied by
 * UI components like the DotTracker, Advance and Reverse Buttons or others.
 *
 * ### Usage
 * ```
 * <Stepper pages={[{component: PageOne}, {component: PageTwo}]}>
 *  <StepperView />
 *  <Row>
 *    <ReverseButton>Back</ReverseButton>
 *    <DotTracker />
 *    <AdvanceButton>Next</AdvanceButton>
 *  </Row>
 * </Stepper>
 * ```
 */
export var Stepper = function (_Component) {
    _inherits(Stepper, _Component);

    function Stepper(props) {
        _classCallCheck(this, Stepper);

        var _this = _possibleConstructorReturn(this, (Stepper.__proto__ || Object.getPrototypeOf(Stepper)).call(this, props));

        _this.allowNavigate = function (fn, toIndex) {
            return __awaiter(_this, void 0, void 0, _regeneratorRuntime.mark(function _callee() {
                var navigate;
                return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                if (!fn) {
                                    _context.next = 7;
                                    break;
                                }

                                _context.next = 3;
                                return fn(toIndex);

                            case 3:
                                navigate = _context.sent;
                                return _context.abrupt('return', navigate !== false);

                            case 7:
                                return _context.abrupt('return', true);

                            case 8:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));
        };
        _this.setPageIndex = function (index) {
            return __awaiter(_this, void 0, void 0, _regeneratorRuntime.mark(function _callee2() {
                var _props, pages, allowJumpAhead, _props$allowJumpBack, allowJumpBack, currentPage, page, nextPage;

                return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                _props = this.props, pages = _props.pages, allowJumpAhead = _props.allowJumpAhead, _props$allowJumpBack = _props.allowJumpBack, allowJumpBack = _props$allowJumpBack === undefined ? true : _props$allowJumpBack;
                                currentPage = this.pageIndex;

                                if (!(index >= pages.length)) {
                                    _context2.next = 4;
                                    break;
                                }

                                throw RangeError('index ' + index + ' is higher than avalible pages ' + pages.length);

                            case 4:
                                if (!(index < 0)) {
                                    _context2.next = 6;
                                    break;
                                }

                                throw RangeError('index ' + index + ' is lower than zero');

                            case 6:
                                page = pages[currentPage];

                                if (!(index > currentPage)) {
                                    _context2.next = 19;
                                    break;
                                }

                                if (!(index > currentPage + 1 && !allowJumpAhead)) {
                                    _context2.next = 10;
                                    break;
                                }

                                return _context2.abrupt('return', false);

                            case 10:
                                _context2.t0 = !this.canAdvance;

                                if (_context2.t0) {
                                    _context2.next = 15;
                                    break;
                                }

                                _context2.next = 14;
                                return this.allowNavigate(page.onAdvance, index);

                            case 14:
                                _context2.t0 = !_context2.sent;

                            case 15:
                                if (!_context2.t0) {
                                    _context2.next = 17;
                                    break;
                                }

                                return _context2.abrupt('return', false);

                            case 17:
                                _context2.next = 28;
                                break;

                            case 19:
                                if (!(index < currentPage - 1 && !allowJumpBack)) {
                                    _context2.next = 21;
                                    break;
                                }

                                return _context2.abrupt('return', false);

                            case 21:
                                _context2.t1 = !this.canReverse;

                                if (_context2.t1) {
                                    _context2.next = 26;
                                    break;
                                }

                                _context2.next = 25;
                                return this.allowNavigate(page.onReverse, index);

                            case 25:
                                _context2.t1 = !_context2.sent;

                            case 26:
                                if (!_context2.t1) {
                                    _context2.next = 28;
                                    break;
                                }

                                return _context2.abrupt('return', false);

                            case 28:
                                _context2.next = 30;
                                return this.allowNavigate(page.onLeave, index);

                            case 30:
                                if (_context2.sent) {
                                    _context2.next = 32;
                                    break;
                                }

                                return _context2.abrupt('return', false);

                            case 32:
                                nextPage = pages[index];
                                _context2.next = 35;
                                return this.allowNavigate(nextPage.onEnter, currentPage);

                            case 35:
                                this._setIndex(index);

                            case 36:
                            case 'end':
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));
        };
        _this.state = { currentPage: props.index || 0 };
        return _this;
    }

    _createClass(Stepper, [{
        key: 'getChildContext',
        value: function getChildContext() {
            return {
                pages: this.props.pages,
                currentPage: this.pageIndex,
                canAdvance: this.canAdvance,
                canFinish: this.canFinish,
                canReverse: this.canReverse,
                setPageIndex: this.setPageIndex
            };
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.pages.length <= this.pageIndex) {
                this._setIndex(0);
            }
            if (nextProps.index !== this.props.index && !nextProps.onChange && typeof nextProps.index === 'number') {
                this._setIndex(nextProps.index);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var children = this.props.children;

            return Children.count(children) < 2 ? children : React.createElement("div", null, children);
        }
    }, {
        key: '_setIndex',
        value: function _setIndex(index) {
            if (this.props.onChange) {
                this.props.onChange(index);
            } else {
                this.setState({ currentPage: index });
            }
        }
    }, {
        key: 'pageIndex',
        get: function get() {
            if (this.props.onChange) return this.props.index;else return this.state.currentPage;
        }
    }, {
        key: 'canAdvance',
        get: function get() {
            var pages = this.props.pages;

            var currentPage = this.pageIndex;
            if (currentPage + 1 >= pages.length) return false;
            var page = pages[currentPage];
            return !page.canAdvance || page.canAdvance();
        }
    }, {
        key: 'canFinish',
        get: function get() {
            var pages = this.props.pages;

            var currentPage = this.pageIndex;
            if (currentPage + 1 < pages.length) return false;
            var page = pages[currentPage];
            return !page.canAdvance || page.canAdvance();
        }
    }, {
        key: 'canReverse',
        get: function get() {
            var currentPage = this.pageIndex;
            if (currentPage <= 0) return false;
            var page = this.props.pages[currentPage];
            return !page.canReverse || page.canReverse();
        }
    }]);

    return Stepper;
}(Component);
Stepper.childContextTypes = stepperContext;
//# sourceMappingURL=stepper.js.map
